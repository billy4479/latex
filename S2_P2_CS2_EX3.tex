\documentclass[12pt]{extarticle}

\title{Computer Science 2, Assignment 3}

\usepackage{preamble_base}
\usepackage{preamble_math}
\usepackage{minted}

\begin{document}

\section*{Computer Science 2, Assignment 3}

\subsection*{Exercise 1}

We want to create a matrix of size $n \times L$ where each entry represents the maximum value we can get on a log of size $j$ using only the first $i$ possible cuts.

At each step either we choose if we want to use the $i$-th cut length or not.
We do so by choosing the maximum between these two prices:
\begin{itemize}
    \item If we use the $i$-th cut size we get a total price of $c_i$ plus the best price we could have gotten with a log of size $j-i$;
    \item If we don't use the $i$-th cut size we get the same price as if we only used $i-1$ cut sizes.
\end{itemize}

We are left with the edge cases:
\begin{itemize}
    \item If $j > i$ it means that we cannot choose the $i$-th cut size because it is larger than the current log;
    \item If $i = 0$ we have to choose the first cut size otherwise we would not cut the log at all.
\end{itemize}

Once the matrix is constructed the best price will be in the bottom-right position and by using the \texttt{reconstruct} function we can get how many cuts and of what size we have to make.

Note that in the code presented here \texttt{cut\_sizes}
is an array of tuples, where the first element of the tuple is the length and the second the price
$[(a_1, c_1), \ldots, (a_n, c_n)]$, with the table in the example it would look like this:
\texttt{cut\_sizes = [(1, 1), (2, 5), (3, 8), (4, 9)]}.

\begin{minted}{python}
def cut_log(cut_sizes, L):
    A = [[0 for _ in range(L)] for _ in range(len(cut_sizes))]

    for row in range(len(cut_sizes)):
        for column in range(L):
            if row == 0:
                A[row][column] = cut_sizes[row][1] 
                    + A[row][column - cut_sizes[row][0]]
            elif row > column:
                A[row][column] = A[row - 1][column]
            else:
                A[row][column] = max(
                    cut_sizes[row][1] + A[row][column - cut_sizes[row][0]],
                    A[row - 1][column],
                )

    print_matrix(A)
    cuts = reconstruct(A, cut_sizes, L)
    return (A[len(cut_sizes) - 1][L - 1], cuts)


def reconstruct(A, cut_sizes, L):
    cuts = {}
    for length, _ in cut_sizes:
        cuts[length] = 0

    row = len(cut_sizes) - 1
    column = L - 1
    while True:
        if A[row][column] == A[row - 1][column]:
            if row == 1:
                break
            cuts[cut_sizes[row][0]] = 0
            row -= 1
        else:
            if row >= column:
                break
            cuts[cut_sizes[row][0]] += 1
            column -= row

    return cuts
\end{minted}

It is easy to see that the time complexity of this algorithm is $\O(nL)$ as we are iterating over a matrix of size $n \times L$.

\subsection*{Exercise 2}

\begin{enumerate}
    \item The maximum flow is 5 and one of the minimum cuts is $U = \{S, B, E, C\}$. It is enough to specify the vertices in one of the partitions of the graph as the other will be $V\setminus U = \{T, F\}$;
    \item No, we can find also $U_1 = \{S, B, E, C,F\}$ and $U_2 = \{S, B\}$ for example which also have capacity 5; \label{2:point_2}
    \item No. Consider the two cuts presented in point \ref{2:point_2}: $\delta^+(U_1) \cap \delta^+(U_1) = \varnothing$, that is, the sets of edges going out of each have no elements in common,
          therefore even if we were to increase the capacity of one one of these cuts the other would still bound the maximum flow to 5.
\end{enumerate}

\end{document}
